---
title: "Getting started"
---

<!-- Parts of this were originally at the end of Chapter 3 - Accessing Data -->

```{r setup, include = FALSE}
# Get and update sample data to avoid messages later
sql.motus <- motus:::get_sample_data()
```

This is a quick introduction to downloading Motus data. Definitely check out the various [articles](../index.html) for more details!

Let's get started by loading the packages we'll use (see also [Chapter 2 - Installing packages](02-installing-packages.html).)

```{r, message = FALSE}
library(motus)
library(dplyr)
library(lubridate)
```

Now we'll download some data, using the `tagme()` function.

We have a choice between two different datasets to download.

1)  By *receiver*. This will download all the detection data for the tags detected by a particular receiver, regardless of what projects deployed the tags.

2)  By *project.* This will download all the detection data for the tags deployed by a particular project, regardless of what projects manage the receivers.

Either way, when you download motus data with the `tagme()` function the data is stored locally on your computer as a SQLite dastabase with the file extension of `.motus`. If you downloaded a receiver data the file name will look something like "SG-123RPI456.motus" and if you downloaded a project tag database the file name will look something like "Project-123.motus".

[You must be part of the project in question to download receiver or tag data. You can't download data from a project you aren't a member of.]

COMMENT: More about the structure of the data. This was in the earlier iteration, and may well (properly) be part of the documentation of the `tagme()` function. But we have to keep in many that many users of Motus are also first time R users and won't know to look at the function documentation to know what's going on.

Here we're downloading project 176 (sample data, use user name and password 'motus.sample'). You can use your own project number or receiver name.

```{r}
sql.motus <- tagme(projRecv = 176, new = FALSE, update = TRUE, dir = "./data/")
```

`tagme()` includes several options. Here we're using:

-   `new = FALSE` means the data base already exists, if it doesn't, change `FALSE` to `TRUE`
-   `dir = "./data/"` means the data base will be stored in the `data` folder inside your current working directory

`tagme()` stores a `project-176.motus` SQLite data base in `./data/`.

We can access parts of the data base by referencing the SQL object we created, `sql.motus`

Here, we'll retrieve the `alltags` view from the SQLite database using the `tbl()` function from the `dplyr` package

```{r}
tbl.alltags <- tbl(sql.motus, "alltags")
```

Next, we can convert this to a data frame (a flat file; see [Converting to flat data in Chapter 3](03-accessing-data.html#converting-to-flat-data))

Convert to flat (`collect()`) and transform the time stamps into date/time format

```{r}
df.alltags <- tbl.alltags %>%
              collect() %>%
              mutate(ts = as_datetime(ts))
```

If you want to save this flat file, you can export as RDS (see [Exporting detections in Chapter 3](03-accessing-data.html#exporting-detections))

```{r}
saveRDS(df.alltags, "my_motus_data.rds")
```

## Workflow summary

For your own data we suggest creating a script (or scripts) with the following workflow:

1.  Download/update your data (see [Chapter 2 - Installing packages](02-installing-packages.html), [Chapter 3 - Accessing detections data](03-accessing-data.html))
2.  Select variables of interest for the table you are working with (typically `alltags`) (see [Chapter 3 - Accessing detections data](03-accessing-data.html), [Chapter 4 - Tag and receiver deployments](04-deployments.html))
3.  Initial cleaning (see [Chapter 4 - Tag and receiver deployments](04-deployments.html) and [Chapter 5 - Data cleaning](05-data-cleaning.html))
4.  Output the resulting data as an .rds file (see [Exporting detections in Chapter 3](03-accessing-data.html#exporting-detections)). We suggest using RDS instead of CSV, because the RDS format preserves the underlying structure of the data (e.g. times stay as times). If you want to export your data to another program, then a CSV format might be preferred.

We caution that producing a flat file using the full suite of fields can use a lot of memory, and can slow R down considerably when dealing with large datasets. For some combinations of data sets and computers, it may be impossible to directly use data frames in R. If that is the case, then this is the point in your workflow where you should carefully consider the information you need from within your data set (for example, how it is aggregated) and simplify it. You can always return to this script and creating a new RDS file with different variables, or aggregated at a different scale.

> **What next?** [Check out the in-depth walkthrough starting with Chapter 1 - Introduction](01-introduction.html)

```{r include = FALSE}
unlink("my_motus_data.rds")
```
